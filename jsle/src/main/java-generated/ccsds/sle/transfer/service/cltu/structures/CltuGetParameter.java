/**
 * This class file was automatically generated by jASN1 v1.11.2 (http://www.beanit.com)
 */

package ccsds.sle.transfer.service.cltu.structures;

import java.io.IOException;
import java.io.EOFException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.io.Serializable;
import com.beanit.jasn1.ber.*;
import com.beanit.jasn1.ber.types.*;
import com.beanit.jasn1.ber.types.string.*;

import ccsds.sle.transfer.service.common.pdus.ReportingCycle;
import ccsds.sle.transfer.service.common.types.ConditionalTime;
import ccsds.sle.transfer.service.common.types.DeliveryMode;
import ccsds.sle.transfer.service.common.types.Diagnostics;
import ccsds.sle.transfer.service.common.types.Duration;
import ccsds.sle.transfer.service.common.types.ForwardDuStatus;
import ccsds.sle.transfer.service.common.types.IntPosLong;
import ccsds.sle.transfer.service.common.types.IntPosShort;
import ccsds.sle.transfer.service.common.types.IntUnsignedLong;
import ccsds.sle.transfer.service.common.types.IntUnsignedShort;
import ccsds.sle.transfer.service.common.types.ParameterName;
import ccsds.sle.transfer.service.common.types.SpaceLinkDataUnit;
import ccsds.sle.transfer.service.common.types.Time;

public class CltuGetParameter implements BerType, Serializable {

	private static final long serialVersionUID = 1L;

	public byte[] code = null;
	public static class ParAcquisitionSequenceLength implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private IntUnsignedShort parameterValue = null;
		
		public ParAcquisitionSequenceLength() {
		}

		public ParAcquisitionSequenceLength(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(IntUnsignedShort parameterValue) {
			this.parameterValue = parameterValue;
		}

		public IntUnsignedShort getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(IntUnsignedShort.tag)) {
				parameterValue = new IntUnsignedShort();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParBitLockRequired implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParBitLockRequired() {
		}

		public ParBitLockRequired(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParClcwGlobalVcId implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private ClcwGvcId parameterValue = null;
		
		public ParClcwGlobalVcId() {
		}

		public ParClcwGlobalVcId(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(ClcwGvcId parameterValue) {
			this.parameterValue = parameterValue;
		}

		public ClcwGvcId getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			parameterValue = new ClcwGvcId();
			subCodeLength += parameterValue.decode(is, berTag);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ");
				parameterValue.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParClcwPhysicalChannel implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private ClcwPhysicalChannel parameterValue = null;
		
		public ParClcwPhysicalChannel() {
		}

		public ParClcwPhysicalChannel(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(ClcwPhysicalChannel parameterValue) {
			this.parameterValue = parameterValue;
		}

		public ClcwPhysicalChannel getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			parameterValue = new ClcwPhysicalChannel();
			subCodeLength += parameterValue.decode(is, berTag);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ");
				parameterValue.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParDeliveryMode implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private CltuDeliveryMode parameterValue = null;
		
		public ParDeliveryMode() {
		}

		public ParDeliveryMode(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(CltuDeliveryMode parameterValue) {
			this.parameterValue = parameterValue;
		}

		public CltuDeliveryMode getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(CltuDeliveryMode.tag)) {
				parameterValue = new CltuDeliveryMode();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParCltuIdentification implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private CltuIdentification parameterValue = null;
		
		public ParCltuIdentification() {
		}

		public ParCltuIdentification(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(CltuIdentification parameterValue) {
			this.parameterValue = parameterValue;
		}

		public CltuIdentification getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(CltuIdentification.tag)) {
				parameterValue = new CltuIdentification();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParEventInvocationIdentification implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private EventInvocationId parameterValue = null;
		
		public ParEventInvocationIdentification() {
		}

		public ParEventInvocationIdentification(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(EventInvocationId parameterValue) {
			this.parameterValue = parameterValue;
		}

		public EventInvocationId getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(EventInvocationId.tag)) {
				parameterValue = new EventInvocationId();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParMaximumCltuLength implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParMaximumCltuLength() {
		}

		public ParMaximumCltuLength(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParMinimumDelayTime implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private Duration parameterValue = null;
		
		public ParMinimumDelayTime() {
		}

		public ParMinimumDelayTime(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(Duration parameterValue) {
			this.parameterValue = parameterValue;
		}

		public Duration getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(Duration.tag)) {
				parameterValue = new Duration();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParMinReportingCycle implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private IntPosShort parameterValue = null;
		
		public ParMinReportingCycle() {
		}

		public ParMinReportingCycle(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(IntPosShort parameterValue) {
			this.parameterValue = parameterValue;
		}

		public IntPosShort getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(IntPosShort.tag)) {
				parameterValue = new IntPosShort();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParModulationFrequency implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private ModulationFrequency parameterValue = null;
		
		public ParModulationFrequency() {
		}

		public ParModulationFrequency(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(ModulationFrequency parameterValue) {
			this.parameterValue = parameterValue;
		}

		public ModulationFrequency getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(ModulationFrequency.tag)) {
				parameterValue = new ModulationFrequency();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParModulationIndex implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private ModulationIndex parameterValue = null;
		
		public ParModulationIndex() {
		}

		public ParModulationIndex(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(ModulationIndex parameterValue) {
			this.parameterValue = parameterValue;
		}

		public ModulationIndex getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(ModulationIndex.tag)) {
				parameterValue = new ModulationIndex();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParNotificationMode implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParNotificationMode() {
		}

		public ParNotificationMode(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParPlop1IdleSequenceLength implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private IntUnsignedShort parameterValue = null;
		
		public ParPlop1IdleSequenceLength() {
		}

		public ParPlop1IdleSequenceLength(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(IntUnsignedShort parameterValue) {
			this.parameterValue = parameterValue;
		}

		public IntUnsignedShort getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(IntUnsignedShort.tag)) {
				parameterValue = new IntUnsignedShort();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParPlopInEffect implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParPlopInEffect() {
		}

		public ParPlopInEffect(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParProtocolAbortMode implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParProtocolAbortMode() {
		}

		public ParProtocolAbortMode(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParReportingCycle implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private CurrentReportingCycle parameterValue = null;
		
		public ParReportingCycle() {
		}

		public ParReportingCycle(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(CurrentReportingCycle parameterValue) {
			this.parameterValue = parameterValue;
		}

		public CurrentReportingCycle getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			parameterValue = new CurrentReportingCycle();
			subCodeLength += parameterValue.decode(is, berTag);
			if (subCodeLength == totalLength) {
				return codeLength;
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ");
				parameterValue.appendAsString(sb, indentLevel + 1);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParReturnTimeout implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private TimeoutPeriod parameterValue = null;
		
		public ParReturnTimeout() {
		}

		public ParReturnTimeout(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(TimeoutPeriod parameterValue) {
			this.parameterValue = parameterValue;
		}

		public TimeoutPeriod getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(TimeoutPeriod.tag)) {
				parameterValue = new TimeoutPeriod();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParRfAvailableRequired implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private BerInteger parameterValue = null;
		
		public ParRfAvailableRequired() {
		}

		public ParRfAvailableRequired(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(BerInteger parameterValue) {
			this.parameterValue = parameterValue;
		}

		public BerInteger getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(BerInteger.tag)) {
				parameterValue = new BerInteger();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	public static class ParSubcarrierToBitRateRatio implements BerType, Serializable {

		private static final long serialVersionUID = 1L;

		public static final BerTag tag = new BerTag(BerTag.UNIVERSAL_CLASS, BerTag.CONSTRUCTED, 16);

		public byte[] code = null;
		private ParameterName parameterName = null;
		private SubcarrierDivisor parameterValue = null;
		
		public ParSubcarrierToBitRateRatio() {
		}

		public ParSubcarrierToBitRateRatio(byte[] code) {
			this.code = code;
		}

		public void setParameterName(ParameterName parameterName) {
			this.parameterName = parameterName;
		}

		public ParameterName getParameterName() {
			return parameterName;
		}

		public void setParameterValue(SubcarrierDivisor parameterValue) {
			this.parameterValue = parameterValue;
		}

		public SubcarrierDivisor getParameterValue() {
			return parameterValue;
		}

		public int encode(OutputStream reverseOS) throws IOException {
			return encode(reverseOS, true);
		}

		public int encode(OutputStream reverseOS, boolean withTag) throws IOException {

			if (code != null) {
				for (int i = code.length - 1; i >= 0; i--) {
					reverseOS.write(code[i]);
				}
				if (withTag) {
					return tag.encode(reverseOS) + code.length;
				}
				return code.length;
			}

			int codeLength = 0;
			codeLength += parameterValue.encode(reverseOS, true);
			
			codeLength += parameterName.encode(reverseOS, true);
			
			codeLength += BerLength.encodeLength(reverseOS, codeLength);

			if (withTag) {
				codeLength += tag.encode(reverseOS);
			}

			return codeLength;

		}

		public int decode(InputStream is) throws IOException {
			return decode(is, true);
		}

		public int decode(InputStream is, boolean withTag) throws IOException {
			int codeLength = 0;
			int subCodeLength = 0;
			BerTag berTag = new BerTag();

			if (withTag) {
				codeLength += tag.decodeAndCheck(is);
			}

			BerLength length = new BerLength();
			codeLength += length.decode(is);

			int totalLength = length.val;
			codeLength += totalLength;

			subCodeLength += berTag.decode(is);
			if (berTag.equals(ParameterName.tag)) {
				parameterName = new ParameterName();
				subCodeLength += parameterName.decode(is, false);
				subCodeLength += berTag.decode(is);
			}
			else {
				throw new IOException("Tag does not match the mandatory sequence element tag.");
			}
			
			if (berTag.equals(SubcarrierDivisor.tag)) {
				parameterValue = new SubcarrierDivisor();
				subCodeLength += parameterValue.decode(is, false);
				if (subCodeLength == totalLength) {
					return codeLength;
				}
			}
			throw new IOException("Unexpected end of sequence, length tag: " + totalLength + ", actual sequence length: " + subCodeLength);

			
		}

		public void encodeAndSave(int encodingSizeGuess) throws IOException {
			ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
			encode(reverseOS, false);
			code = reverseOS.getArray();
		}

		public String toString() {
			StringBuilder sb = new StringBuilder();
			appendAsString(sb, 0);
			return sb.toString();
		}

		public void appendAsString(StringBuilder sb, int indentLevel) {

			sb.append("{");
			sb.append("\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterName != null) {
				sb.append("parameterName: ").append(parameterName);
			}
			else {
				sb.append("parameterName: <empty-required-field>");
			}
			
			sb.append(",\n");
			for (int i = 0; i < indentLevel + 1; i++) {
				sb.append("\t");
			}
			if (parameterValue != null) {
				sb.append("parameterValue: ").append(parameterValue);
			}
			else {
				sb.append("parameterValue: <empty-required-field>");
			}
			
			sb.append("\n");
			for (int i = 0; i < indentLevel; i++) {
				sb.append("\t");
			}
			sb.append("}");
		}

	}

	private ParAcquisitionSequenceLength parAcquisitionSequenceLength = null;
	private ParBitLockRequired parBitLockRequired = null;
	private ParClcwGlobalVcId parClcwGlobalVcId = null;
	private ParClcwPhysicalChannel parClcwPhysicalChannel = null;
	private ParDeliveryMode parDeliveryMode = null;
	private ParCltuIdentification parCltuIdentification = null;
	private ParEventInvocationIdentification parEventInvocationIdentification = null;
	private ParMaximumCltuLength parMaximumCltuLength = null;
	private ParMinimumDelayTime parMinimumDelayTime = null;
	private ParMinReportingCycle parMinReportingCycle = null;
	private ParModulationFrequency parModulationFrequency = null;
	private ParModulationIndex parModulationIndex = null;
	private ParNotificationMode parNotificationMode = null;
	private ParPlop1IdleSequenceLength parPlop1IdleSequenceLength = null;
	private ParPlopInEffect parPlopInEffect = null;
	private ParProtocolAbortMode parProtocolAbortMode = null;
	private ParReportingCycle parReportingCycle = null;
	private ParReturnTimeout parReturnTimeout = null;
	private ParRfAvailableRequired parRfAvailableRequired = null;
	private ParSubcarrierToBitRateRatio parSubcarrierToBitRateRatio = null;
	
	public CltuGetParameter() {
	}

	public CltuGetParameter(byte[] code) {
		this.code = code;
	}

	public void setParAcquisitionSequenceLength(ParAcquisitionSequenceLength parAcquisitionSequenceLength) {
		this.parAcquisitionSequenceLength = parAcquisitionSequenceLength;
	}

	public ParAcquisitionSequenceLength getParAcquisitionSequenceLength() {
		return parAcquisitionSequenceLength;
	}

	public void setParBitLockRequired(ParBitLockRequired parBitLockRequired) {
		this.parBitLockRequired = parBitLockRequired;
	}

	public ParBitLockRequired getParBitLockRequired() {
		return parBitLockRequired;
	}

	public void setParClcwGlobalVcId(ParClcwGlobalVcId parClcwGlobalVcId) {
		this.parClcwGlobalVcId = parClcwGlobalVcId;
	}

	public ParClcwGlobalVcId getParClcwGlobalVcId() {
		return parClcwGlobalVcId;
	}

	public void setParClcwPhysicalChannel(ParClcwPhysicalChannel parClcwPhysicalChannel) {
		this.parClcwPhysicalChannel = parClcwPhysicalChannel;
	}

	public ParClcwPhysicalChannel getParClcwPhysicalChannel() {
		return parClcwPhysicalChannel;
	}

	public void setParDeliveryMode(ParDeliveryMode parDeliveryMode) {
		this.parDeliveryMode = parDeliveryMode;
	}

	public ParDeliveryMode getParDeliveryMode() {
		return parDeliveryMode;
	}

	public void setParCltuIdentification(ParCltuIdentification parCltuIdentification) {
		this.parCltuIdentification = parCltuIdentification;
	}

	public ParCltuIdentification getParCltuIdentification() {
		return parCltuIdentification;
	}

	public void setParEventInvocationIdentification(ParEventInvocationIdentification parEventInvocationIdentification) {
		this.parEventInvocationIdentification = parEventInvocationIdentification;
	}

	public ParEventInvocationIdentification getParEventInvocationIdentification() {
		return parEventInvocationIdentification;
	}

	public void setParMaximumCltuLength(ParMaximumCltuLength parMaximumCltuLength) {
		this.parMaximumCltuLength = parMaximumCltuLength;
	}

	public ParMaximumCltuLength getParMaximumCltuLength() {
		return parMaximumCltuLength;
	}

	public void setParMinimumDelayTime(ParMinimumDelayTime parMinimumDelayTime) {
		this.parMinimumDelayTime = parMinimumDelayTime;
	}

	public ParMinimumDelayTime getParMinimumDelayTime() {
		return parMinimumDelayTime;
	}

	public void setParMinReportingCycle(ParMinReportingCycle parMinReportingCycle) {
		this.parMinReportingCycle = parMinReportingCycle;
	}

	public ParMinReportingCycle getParMinReportingCycle() {
		return parMinReportingCycle;
	}

	public void setParModulationFrequency(ParModulationFrequency parModulationFrequency) {
		this.parModulationFrequency = parModulationFrequency;
	}

	public ParModulationFrequency getParModulationFrequency() {
		return parModulationFrequency;
	}

	public void setParModulationIndex(ParModulationIndex parModulationIndex) {
		this.parModulationIndex = parModulationIndex;
	}

	public ParModulationIndex getParModulationIndex() {
		return parModulationIndex;
	}

	public void setParNotificationMode(ParNotificationMode parNotificationMode) {
		this.parNotificationMode = parNotificationMode;
	}

	public ParNotificationMode getParNotificationMode() {
		return parNotificationMode;
	}

	public void setParPlop1IdleSequenceLength(ParPlop1IdleSequenceLength parPlop1IdleSequenceLength) {
		this.parPlop1IdleSequenceLength = parPlop1IdleSequenceLength;
	}

	public ParPlop1IdleSequenceLength getParPlop1IdleSequenceLength() {
		return parPlop1IdleSequenceLength;
	}

	public void setParPlopInEffect(ParPlopInEffect parPlopInEffect) {
		this.parPlopInEffect = parPlopInEffect;
	}

	public ParPlopInEffect getParPlopInEffect() {
		return parPlopInEffect;
	}

	public void setParProtocolAbortMode(ParProtocolAbortMode parProtocolAbortMode) {
		this.parProtocolAbortMode = parProtocolAbortMode;
	}

	public ParProtocolAbortMode getParProtocolAbortMode() {
		return parProtocolAbortMode;
	}

	public void setParReportingCycle(ParReportingCycle parReportingCycle) {
		this.parReportingCycle = parReportingCycle;
	}

	public ParReportingCycle getParReportingCycle() {
		return parReportingCycle;
	}

	public void setParReturnTimeout(ParReturnTimeout parReturnTimeout) {
		this.parReturnTimeout = parReturnTimeout;
	}

	public ParReturnTimeout getParReturnTimeout() {
		return parReturnTimeout;
	}

	public void setParRfAvailableRequired(ParRfAvailableRequired parRfAvailableRequired) {
		this.parRfAvailableRequired = parRfAvailableRequired;
	}

	public ParRfAvailableRequired getParRfAvailableRequired() {
		return parRfAvailableRequired;
	}

	public void setParSubcarrierToBitRateRatio(ParSubcarrierToBitRateRatio parSubcarrierToBitRateRatio) {
		this.parSubcarrierToBitRateRatio = parSubcarrierToBitRateRatio;
	}

	public ParSubcarrierToBitRateRatio getParSubcarrierToBitRateRatio() {
		return parSubcarrierToBitRateRatio;
	}

	public int encode(OutputStream reverseOS) throws IOException {

		if (code != null) {
			for (int i = code.length - 1; i >= 0; i--) {
				reverseOS.write(code[i]);
			}
			return code.length;
		}

		int codeLength = 0;
		if (parSubcarrierToBitRateRatio != null) {
			codeLength += parSubcarrierToBitRateRatio.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 18
			reverseOS.write(0xB2);
			codeLength += 1;
			return codeLength;
		}
		
		if (parRfAvailableRequired != null) {
			codeLength += parRfAvailableRequired.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 17
			reverseOS.write(0xB1);
			codeLength += 1;
			return codeLength;
		}
		
		if (parReturnTimeout != null) {
			codeLength += parReturnTimeout.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 16
			reverseOS.write(0xB0);
			codeLength += 1;
			return codeLength;
		}
		
		if (parReportingCycle != null) {
			codeLength += parReportingCycle.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 15
			reverseOS.write(0xAF);
			codeLength += 1;
			return codeLength;
		}
		
		if (parProtocolAbortMode != null) {
			codeLength += parProtocolAbortMode.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 14
			reverseOS.write(0xAE);
			codeLength += 1;
			return codeLength;
		}
		
		if (parPlopInEffect != null) {
			codeLength += parPlopInEffect.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 13
			reverseOS.write(0xAD);
			codeLength += 1;
			return codeLength;
		}
		
		if (parPlop1IdleSequenceLength != null) {
			codeLength += parPlop1IdleSequenceLength.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 12
			reverseOS.write(0xAC);
			codeLength += 1;
			return codeLength;
		}
		
		if (parNotificationMode != null) {
			codeLength += parNotificationMode.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 11
			reverseOS.write(0xAB);
			codeLength += 1;
			return codeLength;
		}
		
		if (parModulationIndex != null) {
			codeLength += parModulationIndex.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 10
			reverseOS.write(0xAA);
			codeLength += 1;
			return codeLength;
		}
		
		if (parModulationFrequency != null) {
			codeLength += parModulationFrequency.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 9
			reverseOS.write(0xA9);
			codeLength += 1;
			return codeLength;
		}
		
		if (parMinReportingCycle != null) {
			codeLength += parMinReportingCycle.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 19
			reverseOS.write(0xB3);
			codeLength += 1;
			return codeLength;
		}
		
		if (parMinimumDelayTime != null) {
			codeLength += parMinimumDelayTime.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 8
			reverseOS.write(0xA8);
			codeLength += 1;
			return codeLength;
		}
		
		if (parMaximumCltuLength != null) {
			codeLength += parMaximumCltuLength.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 7
			reverseOS.write(0xA7);
			codeLength += 1;
			return codeLength;
		}
		
		if (parEventInvocationIdentification != null) {
			codeLength += parEventInvocationIdentification.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 6
			reverseOS.write(0xA6);
			codeLength += 1;
			return codeLength;
		}
		
		if (parCltuIdentification != null) {
			codeLength += parCltuIdentification.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 5
			reverseOS.write(0xA5);
			codeLength += 1;
			return codeLength;
		}
		
		if (parDeliveryMode != null) {
			codeLength += parDeliveryMode.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 4
			reverseOS.write(0xA4);
			codeLength += 1;
			return codeLength;
		}
		
		if (parClcwPhysicalChannel != null) {
			codeLength += parClcwPhysicalChannel.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 3
			reverseOS.write(0xA3);
			codeLength += 1;
			return codeLength;
		}
		
		if (parClcwGlobalVcId != null) {
			codeLength += parClcwGlobalVcId.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 2
			reverseOS.write(0xA2);
			codeLength += 1;
			return codeLength;
		}
		
		if (parBitLockRequired != null) {
			codeLength += parBitLockRequired.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 1
			reverseOS.write(0xA1);
			codeLength += 1;
			return codeLength;
		}
		
		if (parAcquisitionSequenceLength != null) {
			codeLength += parAcquisitionSequenceLength.encode(reverseOS, false);
			// write tag: CONTEXT_CLASS, CONSTRUCTED, 0
			reverseOS.write(0xA0);
			codeLength += 1;
			return codeLength;
		}
		
		throw new IOException("Error encoding CHOICE: No element of CHOICE was selected.");
	}

	public int decode(InputStream is) throws IOException {
		return decode(is, null);
	}

	public int decode(InputStream is, BerTag berTag) throws IOException {

		int codeLength = 0;
		BerTag passedTag = berTag;

		if (berTag == null) {
			berTag = new BerTag();
			codeLength += berTag.decode(is);
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 0)) {
			parAcquisitionSequenceLength = new ParAcquisitionSequenceLength();
			codeLength += parAcquisitionSequenceLength.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 1)) {
			parBitLockRequired = new ParBitLockRequired();
			codeLength += parBitLockRequired.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 2)) {
			parClcwGlobalVcId = new ParClcwGlobalVcId();
			codeLength += parClcwGlobalVcId.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 3)) {
			parClcwPhysicalChannel = new ParClcwPhysicalChannel();
			codeLength += parClcwPhysicalChannel.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 4)) {
			parDeliveryMode = new ParDeliveryMode();
			codeLength += parDeliveryMode.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 5)) {
			parCltuIdentification = new ParCltuIdentification();
			codeLength += parCltuIdentification.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 6)) {
			parEventInvocationIdentification = new ParEventInvocationIdentification();
			codeLength += parEventInvocationIdentification.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 7)) {
			parMaximumCltuLength = new ParMaximumCltuLength();
			codeLength += parMaximumCltuLength.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 8)) {
			parMinimumDelayTime = new ParMinimumDelayTime();
			codeLength += parMinimumDelayTime.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 19)) {
			parMinReportingCycle = new ParMinReportingCycle();
			codeLength += parMinReportingCycle.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 9)) {
			parModulationFrequency = new ParModulationFrequency();
			codeLength += parModulationFrequency.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 10)) {
			parModulationIndex = new ParModulationIndex();
			codeLength += parModulationIndex.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 11)) {
			parNotificationMode = new ParNotificationMode();
			codeLength += parNotificationMode.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 12)) {
			parPlop1IdleSequenceLength = new ParPlop1IdleSequenceLength();
			codeLength += parPlop1IdleSequenceLength.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 13)) {
			parPlopInEffect = new ParPlopInEffect();
			codeLength += parPlopInEffect.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 14)) {
			parProtocolAbortMode = new ParProtocolAbortMode();
			codeLength += parProtocolAbortMode.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 15)) {
			parReportingCycle = new ParReportingCycle();
			codeLength += parReportingCycle.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 16)) {
			parReturnTimeout = new ParReturnTimeout();
			codeLength += parReturnTimeout.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 17)) {
			parRfAvailableRequired = new ParRfAvailableRequired();
			codeLength += parRfAvailableRequired.decode(is, false);
			return codeLength;
		}

		if (berTag.equals(BerTag.CONTEXT_CLASS, BerTag.CONSTRUCTED, 18)) {
			parSubcarrierToBitRateRatio = new ParSubcarrierToBitRateRatio();
			codeLength += parSubcarrierToBitRateRatio.decode(is, false);
			return codeLength;
		}

		if (passedTag != null) {
			return 0;
		}

		throw new IOException("Error decoding CHOICE: Tag " + berTag + " matched to no item.");
	}

	public void encodeAndSave(int encodingSizeGuess) throws IOException {
		ReverseByteArrayOutputStream reverseOS = new ReverseByteArrayOutputStream(encodingSizeGuess);
		encode(reverseOS);
		code = reverseOS.getArray();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		appendAsString(sb, 0);
		return sb.toString();
	}

	public void appendAsString(StringBuilder sb, int indentLevel) {

		if (parAcquisitionSequenceLength != null) {
			sb.append("parAcquisitionSequenceLength: ");
			parAcquisitionSequenceLength.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parBitLockRequired != null) {
			sb.append("parBitLockRequired: ");
			parBitLockRequired.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parClcwGlobalVcId != null) {
			sb.append("parClcwGlobalVcId: ");
			parClcwGlobalVcId.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parClcwPhysicalChannel != null) {
			sb.append("parClcwPhysicalChannel: ");
			parClcwPhysicalChannel.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parDeliveryMode != null) {
			sb.append("parDeliveryMode: ");
			parDeliveryMode.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parCltuIdentification != null) {
			sb.append("parCltuIdentification: ");
			parCltuIdentification.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parEventInvocationIdentification != null) {
			sb.append("parEventInvocationIdentification: ");
			parEventInvocationIdentification.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parMaximumCltuLength != null) {
			sb.append("parMaximumCltuLength: ");
			parMaximumCltuLength.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parMinimumDelayTime != null) {
			sb.append("parMinimumDelayTime: ");
			parMinimumDelayTime.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parMinReportingCycle != null) {
			sb.append("parMinReportingCycle: ");
			parMinReportingCycle.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parModulationFrequency != null) {
			sb.append("parModulationFrequency: ");
			parModulationFrequency.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parModulationIndex != null) {
			sb.append("parModulationIndex: ");
			parModulationIndex.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parNotificationMode != null) {
			sb.append("parNotificationMode: ");
			parNotificationMode.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parPlop1IdleSequenceLength != null) {
			sb.append("parPlop1IdleSequenceLength: ");
			parPlop1IdleSequenceLength.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parPlopInEffect != null) {
			sb.append("parPlopInEffect: ");
			parPlopInEffect.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parProtocolAbortMode != null) {
			sb.append("parProtocolAbortMode: ");
			parProtocolAbortMode.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parReportingCycle != null) {
			sb.append("parReportingCycle: ");
			parReportingCycle.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parReturnTimeout != null) {
			sb.append("parReturnTimeout: ");
			parReturnTimeout.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parRfAvailableRequired != null) {
			sb.append("parRfAvailableRequired: ");
			parRfAvailableRequired.appendAsString(sb, indentLevel + 1);
			return;
		}

		if (parSubcarrierToBitRateRatio != null) {
			sb.append("parSubcarrierToBitRateRatio: ");
			parSubcarrierToBitRateRatio.appendAsString(sb, indentLevel + 1);
			return;
		}

		sb.append("<none>");
	}

}

